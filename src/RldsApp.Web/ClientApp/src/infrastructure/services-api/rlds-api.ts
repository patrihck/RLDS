/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.10.2.0 (NJsonSchema v10.3.4.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IRolesClient {
    getRoles(v: string): Observable<PagedDataInquiryResponseOfRole>;
    getRoleById(roleId: number, v: string): Observable<Role>;
    getRoleByName(roleName: string | null, v: string): Observable<Role>;
}

@Injectable({
    providedIn: 'root'
})
export class RolesClient implements IRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRoles(v: string): Observable<PagedDataInquiryResponseOfRole> {
        let url_ = this.baseUrl + "/api/{v}/Roles";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoles(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfRole>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfRole>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoles(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfRole> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfRole.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfRole>(<any>null);
    }

    getRoleById(roleId: number, v: string): Observable<Role> {
        let url_ = this.baseUrl + "/api/{v}/Roles/{roleId}";
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }

    getRoleByName(roleName: string | null, v: string): Observable<Role> {
        let url_ = this.baseUrl + "/api/{v}/Roles/{roleName}";
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleByName(<any>response_);
                } catch (e) {
                    return <Observable<Role>><any>_observableThrow(e);
                }
            } else
                return <Observable<Role>><any>_observableThrow(response_);
        }));
    }

    protected processGetRoleByName(response: HttpResponseBase): Observable<Role> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Role.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Role>(<any>null);
    }
}

export interface IAccountsClient {
    getAccount(v: string): Observable<PagedDataInquiryResponseOfAccount>;
    addAccount(newAccount: NewAccount, v: string): Observable<Account>;
    getAccountsByUserId(id: number, v: string): Observable<PagedDataInquiryResponseOfAccount>;
    getAccountById(id: number, v: string): Observable<Account>;
    updateAccount(id: number, updatedAccount: any, v: string): Observable<Account>;
    deleteAccount(id: number, v: string): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getAccount(v: string): Observable<PagedDataInquiryResponseOfAccount> {
        let url_ = this.baseUrl + "/api/{v}/Accounts";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccount(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfAccount>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfAccount>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccount(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfAccount>(<any>null);
    }

    addAccount(newAccount: NewAccount, v: string): Observable<Account> {
        let url_ = this.baseUrl + "/api/{v}/Accounts";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddAccount(<any>response_);
                } catch (e) {
                    return <Observable<Account>><any>_observableThrow(e);
                }
            } else
                return <Observable<Account>><any>_observableThrow(response_);
        }));
    }

    protected processAddAccount(response: HttpResponseBase): Observable<Account> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Account>(<any>null);
    }

    getAccountsByUserId(id: number, v: string): Observable<PagedDataInquiryResponseOfAccount> {
        let url_ = this.baseUrl + "/api/{v}/Accounts/GetAccountsByUserId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountsByUserId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountsByUserId(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfAccount>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfAccount>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountsByUserId(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfAccount> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfAccount.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfAccount>(<any>null);
    }

    getAccountById(id: number, v: string): Observable<Account> {
        let url_ = this.baseUrl + "/api/{v}/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountById(<any>response_);
                } catch (e) {
                    return <Observable<Account>><any>_observableThrow(e);
                }
            } else
                return <Observable<Account>><any>_observableThrow(response_);
        }));
    }

    protected processGetAccountById(response: HttpResponseBase): Observable<Account> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Account>(<any>null);
    }

    updateAccount(id: number, updatedAccount: any, v: string): Observable<Account> {
        let url_ = this.baseUrl + "/api/{v}/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedAccount);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(<any>response_);
                } catch (e) {
                    return <Observable<Account>><any>_observableThrow(e);
                }
            } else
                return <Observable<Account>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<Account> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Account.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Account>(<any>null);
    }

    deleteAccount(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/Accounts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

export interface ICurrencyClient {
    getCurrencies(v: string): Observable<PagedDataInquiryResponseOfCurrency>;
    addCurrency(newCurrency: NewCurrency, v: string): Observable<Currency>;
    getCurrencyById(id: number, v: string): Observable<Currency>;
    updateCurrency(id: number, updatedCurrency: any, v: string): Observable<Currency>;
    deleteCurrency(id: number, v: string): Observable<FileResponse | null>;
    getCurrencyByAcronym(acronym: string | null, v: string): Observable<Currency>;
}

@Injectable({
    providedIn: 'root'
})
export class CurrencyClient implements ICurrencyClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCurrencies(v: string): Observable<PagedDataInquiryResponseOfCurrency> {
        let url_ = this.baseUrl + "/api/{v}/currencies";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencies(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencies(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfCurrency>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfCurrency>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencies(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfCurrency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfCurrency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfCurrency>(<any>null);
    }

    addCurrency(newCurrency: NewCurrency, v: string): Observable<Currency> {
        let url_ = this.baseUrl + "/api/{v}/currencies";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCurrency);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCurrency(<any>response_);
                } catch (e) {
                    return <Observable<Currency>><any>_observableThrow(e);
                }
            } else
                return <Observable<Currency>><any>_observableThrow(response_);
        }));
    }

    protected processAddCurrency(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Currency>(<any>null);
    }

    getCurrencyById(id: number, v: string): Observable<Currency> {
        let url_ = this.baseUrl + "/api/{v}/currencies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyById(<any>response_);
                } catch (e) {
                    return <Observable<Currency>><any>_observableThrow(e);
                }
            } else
                return <Observable<Currency>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyById(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Currency>(<any>null);
    }

    updateCurrency(id: number, updatedCurrency: any, v: string): Observable<Currency> {
        let url_ = this.baseUrl + "/api/{v}/currencies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedCurrency);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrency(<any>response_);
                } catch (e) {
                    return <Observable<Currency>><any>_observableThrow(e);
                }
            } else
                return <Observable<Currency>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrency(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Currency>(<any>null);
    }

    deleteCurrency(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/currencies/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrency(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCurrency(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getCurrencyByAcronym(acronym: string | null, v: string): Observable<Currency> {
        let url_ = this.baseUrl + "/api/{v}/currencies/{acronym}";
        if (acronym === undefined || acronym === null)
            throw new Error("The parameter 'acronym' must be defined.");
        url_ = url_.replace("{acronym}", encodeURIComponent("" + acronym));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyByAcronym(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyByAcronym(<any>response_);
                } catch (e) {
                    return <Observable<Currency>><any>_observableThrow(e);
                }
            } else
                return <Observable<Currency>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyByAcronym(response: HttpResponseBase): Observable<Currency> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Currency.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Currency>(<any>null);
    }
}

export interface ICurrencyRatesClient {
    getCurrencyRates(sourceCurrencyId: number, targetCurrencyId: number, v: string): Observable<PagedDataInquiryResponseOfCurrencyRate>;
    getCurrencyRateByDate(sourceCurrencyId: number, targetCurrencyId: number, date: string, v: string): Observable<CurrencyRate>;
    updateCurrencyRate(sourceCurrencyId: number, targetCurrencyId: number, date: string, updatedCurrencyRate: any, v: string): Observable<CurrencyRate>;
    deleteCurrencyRate(sourceCurrencyId: number, targetCurrencyId: number, date: string, v: string): Observable<FileResponse | null>;
    addCurrencyRate(newCurrencyRate: NewCurrencyRate, v: string): Observable<CurrencyRate>;
}

@Injectable({
    providedIn: 'root'
})
export class CurrencyRatesClient implements ICurrencyRatesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getCurrencyRates(sourceCurrencyId: number, targetCurrencyId: number, v: string): Observable<PagedDataInquiryResponseOfCurrencyRate> {
        let url_ = this.baseUrl + "/api/{v}/currency-rates/{sourceCurrencyId}/{targetCurrencyId}";
        if (sourceCurrencyId === undefined || sourceCurrencyId === null)
            throw new Error("The parameter 'sourceCurrencyId' must be defined.");
        url_ = url_.replace("{sourceCurrencyId}", encodeURIComponent("" + sourceCurrencyId));
        if (targetCurrencyId === undefined || targetCurrencyId === null)
            throw new Error("The parameter 'targetCurrencyId' must be defined.");
        url_ = url_.replace("{targetCurrencyId}", encodeURIComponent("" + targetCurrencyId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyRates(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyRates(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfCurrencyRate>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfCurrencyRate>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyRates(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfCurrencyRate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfCurrencyRate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfCurrencyRate>(<any>null);
    }

    getCurrencyRateByDate(sourceCurrencyId: number, targetCurrencyId: number, date: string, v: string): Observable<CurrencyRate> {
        let url_ = this.baseUrl + "/api/{v}/currency-rates/{sourceCurrencyId}/{targetCurrencyId}/{date}";
        if (sourceCurrencyId === undefined || sourceCurrencyId === null)
            throw new Error("The parameter 'sourceCurrencyId' must be defined.");
        url_ = url_.replace("{sourceCurrencyId}", encodeURIComponent("" + sourceCurrencyId));
        if (targetCurrencyId === undefined || targetCurrencyId === null)
            throw new Error("The parameter 'targetCurrencyId' must be defined.");
        url_ = url_.replace("{targetCurrencyId}", encodeURIComponent("" + targetCurrencyId));
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetCurrencyRateByDate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCurrencyRateByDate(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyRate>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyRate>><any>_observableThrow(response_);
        }));
    }

    protected processGetCurrencyRateByDate(response: HttpResponseBase): Observable<CurrencyRate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyRate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyRate>(<any>null);
    }

    updateCurrencyRate(sourceCurrencyId: number, targetCurrencyId: number, date: string, updatedCurrencyRate: any, v: string): Observable<CurrencyRate> {
        let url_ = this.baseUrl + "/api/{v}/currency-rates/{sourceCurrencyId}/{targetCurrencyId}/{date}";
        if (sourceCurrencyId === undefined || sourceCurrencyId === null)
            throw new Error("The parameter 'sourceCurrencyId' must be defined.");
        url_ = url_.replace("{sourceCurrencyId}", encodeURIComponent("" + sourceCurrencyId));
        if (targetCurrencyId === undefined || targetCurrencyId === null)
            throw new Error("The parameter 'targetCurrencyId' must be defined.");
        url_ = url_.replace("{targetCurrencyId}", encodeURIComponent("" + targetCurrencyId));
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedCurrencyRate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateCurrencyRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCurrencyRate(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyRate>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyRate>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateCurrencyRate(response: HttpResponseBase): Observable<CurrencyRate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyRate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyRate>(<any>null);
    }

    deleteCurrencyRate(sourceCurrencyId: number, targetCurrencyId: number, date: string, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/currency-rates/{sourceCurrencyId}/{targetCurrencyId}/{date}";
        if (sourceCurrencyId === undefined || sourceCurrencyId === null)
            throw new Error("The parameter 'sourceCurrencyId' must be defined.");
        url_ = url_.replace("{sourceCurrencyId}", encodeURIComponent("" + sourceCurrencyId));
        if (targetCurrencyId === undefined || targetCurrencyId === null)
            throw new Error("The parameter 'targetCurrencyId' must be defined.");
        url_ = url_.replace("{targetCurrencyId}", encodeURIComponent("" + targetCurrencyId));
        if (date === undefined || date === null)
            throw new Error("The parameter 'date' must be defined.");
        url_ = url_.replace("{date}", encodeURIComponent("" + date));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteCurrencyRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCurrencyRate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCurrencyRate(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    addCurrencyRate(newCurrencyRate: NewCurrencyRate, v: string): Observable<CurrencyRate> {
        let url_ = this.baseUrl + "/api/{v}/currency-rates";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCurrencyRate);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddCurrencyRate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddCurrencyRate(<any>response_);
                } catch (e) {
                    return <Observable<CurrencyRate>><any>_observableThrow(e);
                }
            } else
                return <Observable<CurrencyRate>><any>_observableThrow(response_);
        }));
    }

    protected processAddCurrencyRate(response: HttpResponseBase): Observable<CurrencyRate> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrencyRate.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CurrencyRate>(<any>null);
    }
}

export interface IGroupsClient {
    getGroup(v: string): Observable<PagedDataInquiryResponseOfGroup>;
    addGroup(newGroup: NewGroup, v: string): Observable<Group>;
    getGroupById(groupId: number, v: string): Observable<Group>;
    updateGroup(groupId: number, updatedGroup: any, v: string): Observable<Group>;
    deleteGroup(groupId: number, v: string): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class GroupsClient implements IGroupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getGroup(v: string): Observable<PagedDataInquiryResponseOfGroup> {
        let url_ = this.baseUrl + "/api/{v}/Groups";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroup(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfGroup>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfGroup>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroup(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfGroup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfGroup.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfGroup>(<any>null);
    }

    addGroup(newGroup: NewGroup, v: string): Observable<Group> {
        let url_ = this.baseUrl + "/api/{v}/Groups";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddGroup(<any>response_);
                } catch (e) {
                    return <Observable<Group>><any>_observableThrow(e);
                }
            } else
                return <Observable<Group>><any>_observableThrow(response_);
        }));
    }

    protected processAddGroup(response: HttpResponseBase): Observable<Group> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Group>(<any>null);
    }

    getGroupById(groupId: number, v: string): Observable<Group> {
        let url_ = this.baseUrl + "/api/{v}/Groups/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupById(<any>response_);
                } catch (e) {
                    return <Observable<Group>><any>_observableThrow(e);
                }
            } else
                return <Observable<Group>><any>_observableThrow(response_);
        }));
    }

    protected processGetGroupById(response: HttpResponseBase): Observable<Group> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Group>(<any>null);
    }

    updateGroup(groupId: number, updatedGroup: any, v: string): Observable<Group> {
        let url_ = this.baseUrl + "/api/{v}/Groups/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedGroup);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateGroup(<any>response_);
                } catch (e) {
                    return <Observable<Group>><any>_observableThrow(e);
                }
            } else
                return <Observable<Group>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateGroup(response: HttpResponseBase): Observable<Group> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Group.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Group>(<any>null);
    }

    deleteGroup(groupId: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/Groups/{groupId}";
        if (groupId === undefined || groupId === null)
            throw new Error("The parameter 'groupId' must be defined.");
        url_ = url_.replace("{groupId}", encodeURIComponent("" + groupId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteGroup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteGroup(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }
}

export interface IPlannedTransactionsClient {
    getPlannedTransactions(v: string, dateFrom?: string | undefined, dateTo?: string | undefined): Observable<PagedDataInquiryResponseOfTransaction>;
}

@Injectable({
    providedIn: 'root'
})
export class PlannedTransactionsClient implements IPlannedTransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getPlannedTransactions(v: string, dateFrom?: string | undefined, dateTo?: string | undefined): Observable<PagedDataInquiryResponseOfTransaction> {
        let url_ = this.baseUrl + "/api/{v}/PlannedTransactions?";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        if (dateFrom === null)
            throw new Error("The parameter 'dateFrom' cannot be null.");
        else if (dateFrom !== undefined)
            url_ += "dateFrom=" + encodeURIComponent("" + dateFrom) + "&";
        if (dateTo === null)
            throw new Error("The parameter 'dateTo' cannot be null.");
        else if (dateTo !== undefined)
            url_ += "dateTo=" + encodeURIComponent("" + dateTo) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPlannedTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPlannedTransactions(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetPlannedTransactions(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransaction>(<any>null);
    }
}

export interface IRecurringTransactionsClient {
    getRecurringTransactionById(id: number, v: string): Observable<RecurringTransaction>;
    updateRecurringTransaction(id: number, updatedRecurringTransaction: any, v: string): Observable<RecurringTransaction>;
    deleteRecurringTransaction(id: number, v: string): Observable<FileResponse | null>;
    getRecurringTransactions(v: string): Observable<PagedDataInquiryResponseOfRecurringTransaction>;
    addRecurringTransaction(newRecurringTransaction: NewRecurringTransaction, v: string): Observable<RecurringTransaction>;
}

@Injectable({
    providedIn: 'root'
})
export class RecurringTransactionsClient implements IRecurringTransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getRecurringTransactionById(id: number, v: string): Observable<RecurringTransaction> {
        let url_ = this.baseUrl + "/api/{v}/RecurringTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurringTransactionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurringTransactionById(<any>response_);
                } catch (e) {
                    return <Observable<RecurringTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurringTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecurringTransactionById(response: HttpResponseBase): Observable<RecurringTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecurringTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringTransaction>(<any>null);
    }

    updateRecurringTransaction(id: number, updatedRecurringTransaction: any, v: string): Observable<RecurringTransaction> {
        let url_ = this.baseUrl + "/api/{v}/RecurringTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedRecurringTransaction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRecurringTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRecurringTransaction(<any>response_);
                } catch (e) {
                    return <Observable<RecurringTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurringTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateRecurringTransaction(response: HttpResponseBase): Observable<RecurringTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecurringTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringTransaction>(<any>null);
    }

    deleteRecurringTransaction(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/RecurringTransactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRecurringTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRecurringTransaction(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteRecurringTransaction(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getRecurringTransactions(v: string): Observable<PagedDataInquiryResponseOfRecurringTransaction> {
        let url_ = this.baseUrl + "/api/{v}/RecurringTransactions";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecurringTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecurringTransactions(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfRecurringTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfRecurringTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecurringTransactions(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfRecurringTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfRecurringTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfRecurringTransaction>(<any>null);
    }

    addRecurringTransaction(newRecurringTransaction: NewRecurringTransaction, v: string): Observable<RecurringTransaction> {
        let url_ = this.baseUrl + "/api/{v}/RecurringTransactions";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newRecurringTransaction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddRecurringTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddRecurringTransaction(<any>response_);
                } catch (e) {
                    return <Observable<RecurringTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecurringTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processAddRecurringTransaction(response: HttpResponseBase): Observable<RecurringTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RecurringTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecurringTransaction>(<any>null);
    }
}

export interface ITasksClient {
    getTaskById(id: number, v: string): Observable<Task>;
    getTasks(v: string): Observable<PagedDataInquiryResponseOfTask>;
}

@Injectable({
    providedIn: 'root'
})
export class TasksClient implements ITasksClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTaskById(id: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/Tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTaskById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTaskById(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processGetTaskById(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    getTasks(v: string): Observable<PagedDataInquiryResponseOfTask> {
        let url_ = this.baseUrl + "/api/{v}/Tasks";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTasks(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTasks(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTask>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTask>><any>_observableThrow(response_);
        }));
    }

    protected processGetTasks(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTask> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTask.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTask>(<any>null);
    }
}

export interface ITaskUsersClient {
    replaceTaskUsers(taskId: number, userIds: number[], v: string): Observable<Task>;
    deleteTaskUsers(taskId: number, v: string): Observable<Task>;
    addTaskUser(taskId: number, userId: number, v: string): Observable<Task>;
    deleteTaskUser(taskId: number, userId: number, v: string): Observable<Task>;
}

@Injectable({
    providedIn: 'root'
})
export class TaskUsersClient implements ITaskUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    replaceTaskUsers(taskId: number, userIds: number[], v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskUsers/{taskId}/users";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceTaskUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceTaskUsers(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceTaskUsers(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    deleteTaskUsers(taskId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskUsers/{taskId}/users";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaskUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaskUsers(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaskUsers(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    addTaskUser(taskId: number, userId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskUsers/{taskId}/users/{userId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTaskUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTaskUser(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processAddTaskUser(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    deleteTaskUser(taskId: number, userId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskUsers/{taskId}/users/{userId}";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTaskUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTaskUser(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTaskUser(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }
}

export interface ITaskWorkflowClient {
    startTask(taskId: number, v: string): Observable<Task>;
    completeTask(taskId: number, v: string): Observable<Task>;
    reactivateTask(taskId: number, v: string): Observable<Task>;
}

@Injectable({
    providedIn: 'root'
})
export class TaskWorkflowClient implements ITaskWorkflowClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    startTask(taskId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskWorkflow/tasks/{taskId}/activations";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStartTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStartTask(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processStartTask(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    completeTask(taskId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskWorkflow/tasks/{taskId}/completions";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCompleteTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompleteTask(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processCompleteTask(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }

    reactivateTask(taskId: number, v: string): Observable<Task> {
        let url_ = this.baseUrl + "/api/{v}/TaskWorkflow/tasks/{taskId}/reactivations";
        if (taskId === undefined || taskId === null)
            throw new Error("The parameter 'taskId' must be defined.");
        url_ = url_.replace("{taskId}", encodeURIComponent("" + taskId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReactivateTask(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReactivateTask(<any>response_);
                } catch (e) {
                    return <Observable<Task>><any>_observableThrow(e);
                }
            } else
                return <Observable<Task>><any>_observableThrow(response_);
        }));
    }

    protected processReactivateTask(response: HttpResponseBase): Observable<Task> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Task.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Task>(<any>null);
    }
}

export interface ITransactionCategoryClient {
    addTransactionCategory(newTransactionCategory: NewTransactionCategory, v: string): Observable<TransactionCategory>;
    getTransactionCategories(v: string): Observable<PagedDataInquiryResponseOfTransactionCategory>;
    deleteTransactionCategory(id: number, v: string): Observable<FileResponse | null>;
    getTransactionCategoryById(id: number, v: string): Observable<TransactionCategory>;
    updateTransactionCategory(id: number, updatedTransactionCategory: any, v: string): Observable<TransactionCategory>;
}

@Injectable({
    providedIn: 'root'
})
export class TransactionCategoryClient implements ITransactionCategoryClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    addTransactionCategory(newTransactionCategory: NewTransactionCategory, v: string): Observable<TransactionCategory> {
        let url_ = this.baseUrl + "/api/{v}/transaction-categories";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newTransactionCategory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTransactionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTransactionCategory(<any>response_);
                } catch (e) {
                    return <Observable<TransactionCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionCategory>><any>_observableThrow(response_);
        }));
    }

    protected processAddTransactionCategory(response: HttpResponseBase): Observable<TransactionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCategory>(<any>null);
    }

    getTransactionCategories(v: string): Observable<PagedDataInquiryResponseOfTransactionCategory> {
        let url_ = this.baseUrl + "/api/{v}/transaction-categories";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionCategories(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionCategories(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransactionCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransactionCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionCategories(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransactionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransactionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransactionCategory>(<any>null);
    }

    deleteTransactionCategory(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/transaction-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransactionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransactionCategory(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTransactionCategory(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getTransactionCategoryById(id: number, v: string): Observable<TransactionCategory> {
        let url_ = this.baseUrl + "/api/{v}/transaction-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionCategoryById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionCategoryById(<any>response_);
                } catch (e) {
                    return <Observable<TransactionCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionCategoryById(response: HttpResponseBase): Observable<TransactionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCategory>(<any>null);
    }

    updateTransactionCategory(id: number, updatedTransactionCategory: any, v: string): Observable<TransactionCategory> {
        let url_ = this.baseUrl + "/api/{v}/transaction-categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedTransactionCategory);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransactionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransactionCategory(<any>response_);
                } catch (e) {
                    return <Observable<TransactionCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionCategory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransactionCategory(response: HttpResponseBase): Observable<TransactionCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionCategory>(<any>null);
    }
}

export interface ITransactionsClient {
    getTransactionById(id: number, v: string): Observable<Transaction>;
    updateTransaction(id: number, updatedTransaction: any, v: string): Observable<Transaction>;
    deleteTransaction(id: number, v: string): Observable<FileResponse | null>;
    getTransactionsByAccountId(id: number, v: string): Observable<PagedDataInquiryResponseOfTransaction>;
    getTransactions(v: string): Observable<PagedDataInquiryResponseOfTransaction>;
    addTransaction(newTransaction: NewTransaction, v: string): Observable<Transaction>;
}

@Injectable({
    providedIn: 'root'
})
export class TransactionsClient implements ITransactionsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTransactionById(id: number, v: string): Observable<Transaction> {
        let url_ = this.baseUrl + "/api/{v}/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionById(<any>response_);
                } catch (e) {
                    return <Observable<Transaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionById(response: HttpResponseBase): Observable<Transaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transaction>(<any>null);
    }

    updateTransaction(id: number, updatedTransaction: any, v: string): Observable<Transaction> {
        let url_ = this.baseUrl + "/api/{v}/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedTransaction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateTransaction(<any>response_);
                } catch (e) {
                    return <Observable<Transaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transaction>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateTransaction(response: HttpResponseBase): Observable<Transaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transaction>(<any>null);
    }

    deleteTransaction(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/Transactions/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteTransaction(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteTransaction(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getTransactionsByAccountId(id: number, v: string): Observable<PagedDataInquiryResponseOfTransaction> {
        let url_ = this.baseUrl + "/api/{v}/Transactions/GetTransactionsByAccountId/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionsByAccountId(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionsByAccountId(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionsByAccountId(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransaction>(<any>null);
    }

    getTransactions(v: string): Observable<PagedDataInquiryResponseOfTransaction> {
        let url_ = this.baseUrl + "/api/{v}/Transactions";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactions(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransaction>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactions(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransaction>(<any>null);
    }

    addTransaction(newTransaction: NewTransaction, v: string): Observable<Transaction> {
        let url_ = this.baseUrl + "/api/{v}/Transactions";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newTransaction);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddTransaction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddTransaction(<any>response_);
                } catch (e) {
                    return <Observable<Transaction>><any>_observableThrow(e);
                }
            } else
                return <Observable<Transaction>><any>_observableThrow(response_);
        }));
    }

    protected processAddTransaction(response: HttpResponseBase): Observable<Transaction> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Transaction.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Transaction>(<any>null);
    }
}

export interface ITransactionStatusClient {
    getTransactionStatusById(id: TransactionStatusValue, v: string): Observable<TransactionStatus>;
    getTransactionStatusByName(name: string | null, v: string): Observable<TransactionStatus>;
    getTransactionStatus(v: string): Observable<PagedDataInquiryResponseOfTransactionStatus>;
}

@Injectable({
    providedIn: 'root'
})
export class TransactionStatusClient implements ITransactionStatusClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTransactionStatusById(id: TransactionStatusValue, v: string): Observable<TransactionStatus> {
        let url_ = this.baseUrl + "/api/{v}/TransactionStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatusById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatusById(<any>response_);
                } catch (e) {
                    return <Observable<TransactionStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionStatusById(response: HttpResponseBase): Observable<TransactionStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionStatus>(<any>null);
    }

    getTransactionStatusByName(name: string | null, v: string): Observable<TransactionStatus> {
        let url_ = this.baseUrl + "/api/{v}/TransactionStatus/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatusByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatusByName(<any>response_);
                } catch (e) {
                    return <Observable<TransactionStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionStatusByName(response: HttpResponseBase): Observable<TransactionStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionStatus>(<any>null);
    }

    getTransactionStatus(v: string): Observable<PagedDataInquiryResponseOfTransactionStatus> {
        let url_ = this.baseUrl + "/api/{v}/TransactionStatus";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionStatus(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransactionStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransactionStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionStatus(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransactionStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransactionStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransactionStatus>(<any>null);
    }
}

export interface ITransactionTypesClient {
    getTransactionTypes(v: string): Observable<PagedDataInquiryResponseOfTransactionType>;
    getTransactionTypeById(id: TransactionTypeValue, v: string): Observable<TransactionType>;
    getTransactionTypeByName(name: string | null, v: string): Observable<TransactionType>;
}

@Injectable({
    providedIn: 'root'
})
export class TransactionTypesClient implements ITransactionTypesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getTransactionTypes(v: string): Observable<PagedDataInquiryResponseOfTransactionType> {
        let url_ = this.baseUrl + "/api/{v}/TransactionTypes";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypes(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfTransactionType>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfTransactionType>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypes(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfTransactionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfTransactionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfTransactionType>(<any>null);
    }

    getTransactionTypeById(id: TransactionTypeValue, v: string): Observable<TransactionType> {
        let url_ = this.baseUrl + "/api/{v}/TransactionTypes/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypeById(<any>response_);
                } catch (e) {
                    return <Observable<TransactionType>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionType>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypeById(response: HttpResponseBase): Observable<TransactionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionType>(<any>null);
    }

    getTransactionTypeByName(name: string | null, v: string): Observable<TransactionType> {
        let url_ = this.baseUrl + "/api/{v}/TransactionTypes/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTransactionTypeByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTransactionTypeByName(<any>response_);
                } catch (e) {
                    return <Observable<TransactionType>><any>_observableThrow(e);
                }
            } else
                return <Observable<TransactionType>><any>_observableThrow(response_);
        }));
    }

    protected processGetTransactionTypeByName(response: HttpResponseBase): Observable<TransactionType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = TransactionType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TransactionType>(<any>null);
    }
}

export interface IUserRolesClient {
    replaceUserRoles(userId: number, roleIds: number[], v: string): Observable<User>;
    deleteUserRoles(userId: number, v: string): Observable<User>;
    addUserRole(userId: number, roleId: number, v: string): Observable<User>;
    deleteUserRole(userId: number, roleId: number, v: string): Observable<User>;
}

@Injectable({
    providedIn: 'root'
})
export class UserRolesClient implements IUserRolesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    replaceUserRoles(userId: number, roleIds: number[], v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleIds);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceUserRoles(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceUserRoles(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    deleteUserRoles(userId: number, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/users/{userId}/roles";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserRoles(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserRoles(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    addUserRole(userId: number, roleId: number, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/users/{userId}/roles/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUserRole(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processAddUserRole(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    deleteUserRole(userId: number, roleId: number, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/users/{userId}/roles/{roleId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        if (roleId === undefined || roleId === null)
            throw new Error("The parameter 'roleId' must be defined.");
        url_ = url_.replace("{roleId}", encodeURIComponent("" + roleId));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUserRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserRole(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUserRole(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }
}

export interface IUsersClient {
    getUsers(v: string): Observable<PagedDataInquiryResponseOfUser>;
    addUser(newUser: NewUser, v: string): Observable<User>;
    getUserById(id: number, v: string): Observable<User>;
    updateUser(id: number, updatedUser: any, v: string): Observable<User>;
    deleteUser(id: number, v: string): Observable<FileResponse | null>;
    getUserByName(name: string | null, v: string): Observable<User>;
    registerUser(newUser: NewUser, v: string): Observable<User>;
    authenticateUser(loginData: LoginData, v: string): Observable<AuthenticatedData>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClient implements IUsersClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    getUsers(v: string): Observable<PagedDataInquiryResponseOfUser> {
        let url_ = this.baseUrl + "/api/{v}/Users";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<PagedDataInquiryResponseOfUser>><any>_observableThrow(e);
                }
            } else
                return <Observable<PagedDataInquiryResponseOfUser>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<PagedDataInquiryResponseOfUser> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PagedDataInquiryResponseOfUser.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PagedDataInquiryResponseOfUser>(<any>null);
    }

    addUser(newUser: NewUser, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/Users";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    getUserById(id: number, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserById(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserById(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    updateUser(id: number, updatedUser: any, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    deleteUser(id: number, v: string): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/{v}/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse | null>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse | null>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse | null>(<any>null);
    }

    getUserByName(name: string | null, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/Users/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserByName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByName(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserByName(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    registerUser(newUser: NewUser, v: string): Observable<User> {
        let url_ = this.baseUrl + "/api/{v}/Users/register";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUser);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    authenticateUser(loginData: LoginData, v: string): Observable<AuthenticatedData> {
        let url_ = this.baseUrl + "/api/{v}/Users/authenticate";
        if (v === undefined || v === null)
            throw new Error("The parameter 'v' must be defined.");
        url_ = url_.replace("{v}", encodeURIComponent("" + v));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginData);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAuthenticateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAuthenticateUser(<any>response_);
                } catch (e) {
                    return <Observable<AuthenticatedData>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthenticatedData>><any>_observableThrow(response_);
        }));
    }

    protected processAuthenticateUser(response: HttpResponseBase): Observable<AuthenticatedData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AuthenticatedData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthenticatedData>(<any>null);
    }
}

export class PagedDataInquiryResponseOfRole implements IPagedDataInquiryResponseOfRole {
    items?: Role[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Role.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfRole {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfRole();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfRole {
    items?: Role[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class Role implements IRole {
    id!: number;
    roleName?: string | undefined;
    users?: UserLeaf[] | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: IRole) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserLeaf.fromJS(item));
            }
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Role {
        data = typeof data === 'object' ? data : {};
        let result = new Role();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRole {
    id: number;
    roleName?: string | undefined;
    users?: UserLeaf[] | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class UserLeaf implements IUserLeaf {
    id!: number;
    login?: string | undefined;
    password?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    email?: string | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: IUserLeaf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.login = _data["login"];
            this.password = _data["password"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): UserLeaf {
        data = typeof data === 'object' ? data : {};
        let result = new UserLeaf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["login"] = this.login;
        data["password"] = this.password;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IUserLeaf {
    id: number;
    login?: string | undefined;
    password?: string | undefined;
    firstname?: string | undefined;
    lastname?: string | undefined;
    email?: string | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class Link implements ILink {
    rel?: string | undefined;
    href?: string | undefined;
    method?: string | undefined;

    constructor(data?: ILink) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rel = _data["rel"];
            this.href = _data["href"];
            this.method = _data["method"];
        }
    }

    static fromJS(data: any): Link {
        data = typeof data === 'object' ? data : {};
        let result = new Link();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rel"] = this.rel;
        data["href"] = this.href;
        data["method"] = this.method;
        return data; 
    }
}

export interface ILink {
    rel?: string | undefined;
    href?: string | undefined;
    method?: string | undefined;
}

export class PagedDataInquiryResponseOfAccount implements IPagedDataInquiryResponseOfAccount {
    items?: Account[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Account.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfAccount {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfAccount {
    items?: Account[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class Account implements IAccount {
    id!: number;
    name?: string | undefined;
    user?: UserLeaf | undefined;
    currency?: Currency | undefined;
    group?: Group | undefined;
    startAmount!: number;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: IAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.user = _data["user"] ? UserLeaf.fromJS(_data["user"]) : <any>undefined;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.group = _data["group"] ? Group.fromJS(_data["group"]) : <any>undefined;
            this.startAmount = _data["startAmount"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Account {
        data = typeof data === 'object' ? data : {};
        let result = new Account();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["startAmount"] = this.startAmount;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IAccount {
    id: number;
    name?: string | undefined;
    user?: UserLeaf | undefined;
    currency?: Currency | undefined;
    group?: Group | undefined;
    startAmount: number;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class Currency implements ICurrency {
    id!: number;
    name?: string | undefined;
    acronym?: string | undefined;
    symbol?: string | undefined;
    isPrefix!: boolean;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.acronym = _data["acronym"];
            this.symbol = _data["symbol"];
            this.isPrefix = _data["isPrefix"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["acronym"] = this.acronym;
        data["symbol"] = this.symbol;
        data["isPrefix"] = this.isPrefix;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICurrency {
    id: number;
    name?: string | undefined;
    acronym?: string | undefined;
    symbol?: string | undefined;
    isPrefix: boolean;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class Group implements IGroup {
    id!: number;
    name?: string | undefined;
    info?: string | undefined;
    ordinal!: number;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: IGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.info = _data["info"];
            this.ordinal = _data["ordinal"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Group {
        data = typeof data === 'object' ? data : {};
        let result = new Group();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["info"] = this.info;
        data["ordinal"] = this.ordinal;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IGroup {
    id: number;
    name?: string | undefined;
    info?: string | undefined;
    ordinal: number;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class NewAccount implements INewAccount {
    name!: string;
    user!: UserLeaf;
    currency!: Currency;
    group?: Group | undefined;
    startAmount!: number;

    constructor(data?: INewAccount) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserLeaf();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.user = _data["user"] ? UserLeaf.fromJS(_data["user"]) : new UserLeaf();
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.group = _data["group"] ? Group.fromJS(_data["group"]) : <any>undefined;
            this.startAmount = _data["startAmount"];
        }
    }

    static fromJS(data: any): NewAccount {
        data = typeof data === 'object' ? data : {};
        let result = new NewAccount();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["group"] = this.group ? this.group.toJSON() : <any>undefined;
        data["startAmount"] = this.startAmount;
        return data; 
    }
}

export interface INewAccount {
    name: string;
    user: UserLeaf;
    currency: Currency;
    group?: Group | undefined;
    startAmount: number;
}

export class PagedDataInquiryResponseOfCurrency implements IPagedDataInquiryResponseOfCurrency {
    items?: Currency[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfCurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Currency.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfCurrency {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfCurrency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfCurrency {
    items?: Currency[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewCurrency implements INewCurrency {
    name!: string;
    acronym!: string;
    symbol!: string;
    isPrefix!: boolean;

    constructor(data?: INewCurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.acronym = _data["acronym"];
            this.symbol = _data["symbol"];
            this.isPrefix = _data["isPrefix"];
        }
    }

    static fromJS(data: any): NewCurrency {
        data = typeof data === 'object' ? data : {};
        let result = new NewCurrency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["acronym"] = this.acronym;
        data["symbol"] = this.symbol;
        data["isPrefix"] = this.isPrefix;
        return data; 
    }
}

export interface INewCurrency {
    name: string;
    acronym: string;
    symbol: string;
    isPrefix: boolean;
}

export class PagedDataInquiryResponseOfCurrencyRate implements IPagedDataInquiryResponseOfCurrencyRate {
    items?: CurrencyRate[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfCurrencyRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(CurrencyRate.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfCurrencyRate {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfCurrencyRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfCurrencyRate {
    items?: CurrencyRate[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class CurrencyRate implements ICurrencyRate {
    sourceCurrency?: Currency | undefined;
    targetCurrency?: Currency | undefined;
    date!: string;
    rate!: number;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: ICurrencyRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceCurrency = _data["sourceCurrency"] ? Currency.fromJS(_data["sourceCurrency"]) : <any>undefined;
            this.targetCurrency = _data["targetCurrency"] ? Currency.fromJS(_data["targetCurrency"]) : <any>undefined;
            this.date = _data["date"];
            this.rate = _data["rate"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CurrencyRate {
        data = typeof data === 'object' ? data : {};
        let result = new CurrencyRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCurrency"] = this.sourceCurrency ? this.sourceCurrency.toJSON() : <any>undefined;
        data["targetCurrency"] = this.targetCurrency ? this.targetCurrency.toJSON() : <any>undefined;
        data["date"] = this.date;
        data["rate"] = this.rate;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ICurrencyRate {
    sourceCurrency?: Currency | undefined;
    targetCurrency?: Currency | undefined;
    date: string;
    rate: number;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class NewCurrencyRate implements INewCurrencyRate {
    sourceCurrency!: Currency;
    targetCurrency!: Currency;
    date!: string;
    rate!: number;

    constructor(data?: INewCurrencyRate) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sourceCurrency = new Currency();
            this.targetCurrency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourceCurrency = _data["sourceCurrency"] ? Currency.fromJS(_data["sourceCurrency"]) : new Currency();
            this.targetCurrency = _data["targetCurrency"] ? Currency.fromJS(_data["targetCurrency"]) : new Currency();
            this.date = _data["date"];
            this.rate = _data["rate"];
        }
    }

    static fromJS(data: any): NewCurrencyRate {
        data = typeof data === 'object' ? data : {};
        let result = new NewCurrencyRate();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourceCurrency"] = this.sourceCurrency ? this.sourceCurrency.toJSON() : <any>undefined;
        data["targetCurrency"] = this.targetCurrency ? this.targetCurrency.toJSON() : <any>undefined;
        data["date"] = this.date;
        data["rate"] = this.rate;
        return data; 
    }
}

export interface INewCurrencyRate {
    sourceCurrency: Currency;
    targetCurrency: Currency;
    date: string;
    rate: number;
}

export class PagedDataInquiryResponseOfGroup implements IPagedDataInquiryResponseOfGroup {
    items?: Group[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Group.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfGroup {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfGroup {
    items?: Group[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewGroup implements INewGroup {
    name!: string;
    info!: string;
    ordinal!: number;

    constructor(data?: INewGroup) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.info = _data["info"];
            this.ordinal = _data["ordinal"];
        }
    }

    static fromJS(data: any): NewGroup {
        data = typeof data === 'object' ? data : {};
        let result = new NewGroup();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["info"] = this.info;
        data["ordinal"] = this.ordinal;
        return data; 
    }
}

export interface INewGroup {
    name: string;
    info: string;
    ordinal: number;
}

export class PagedDataInquiryResponseOfTransaction implements IPagedDataInquiryResponseOfTransaction {
    items?: Transaction[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Transaction.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfTransaction {
    items?: Transaction[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class Transaction implements ITransaction {
    id!: number;
    date!: string;
    user?: UserLeaf | undefined;
    sender?: Account | undefined;
    receiver?: Account | undefined;
    type?: TransactionType | undefined;
    category?: TransactionCategory | undefined;
    status?: TransactionStatus | undefined;
    currency?: Currency | undefined;
    description?: string | undefined;
    amount!: number;
    version?: string | undefined;
    recurringTransaction?: RecurringTransaction | undefined;
    links?: Link[] | undefined;

    constructor(data?: ITransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.date = _data["date"];
            this.user = _data["user"] ? UserLeaf.fromJS(_data["user"]) : <any>undefined;
            this.sender = _data["sender"] ? Account.fromJS(_data["sender"]) : <any>undefined;
            this.receiver = _data["receiver"] ? Account.fromJS(_data["receiver"]) : <any>undefined;
            this.type = _data["type"] ? TransactionType.fromJS(_data["type"]) : <any>undefined;
            this.category = _data["category"] ? TransactionCategory.fromJS(_data["category"]) : <any>undefined;
            this.status = _data["status"] ? TransactionStatus.fromJS(_data["status"]) : <any>undefined;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.version = _data["version"];
            this.recurringTransaction = _data["recurringTransaction"] ? RecurringTransaction.fromJS(_data["recurringTransaction"]) : <any>undefined;
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Transaction {
        data = typeof data === 'object' ? data : {};
        let result = new Transaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["date"] = this.date;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["receiver"] = this.receiver ? this.receiver.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["version"] = this.version;
        data["recurringTransaction"] = this.recurringTransaction ? this.recurringTransaction.toJSON() : <any>undefined;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransaction {
    id: number;
    date: string;
    user?: UserLeaf | undefined;
    sender?: Account | undefined;
    receiver?: Account | undefined;
    type?: TransactionType | undefined;
    category?: TransactionCategory | undefined;
    status?: TransactionStatus | undefined;
    currency?: Currency | undefined;
    description?: string | undefined;
    amount: number;
    version?: string | undefined;
    recurringTransaction?: RecurringTransaction | undefined;
    links?: Link[] | undefined;
}

export class TransactionType implements ITransactionType {
    id!: TransactionTypeValue;
    name?: string | undefined;

    constructor(data?: ITransactionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
        }
    }

    static fromJS(data: any): TransactionType {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        return data; 
    }
}

export interface ITransactionType {
    id: TransactionTypeValue;
    name?: string | undefined;
}

export enum TransactionTypeValue {
    IncomingTransfer = 100,
    OutgoingTransfer = 200,
    Transfer = 300,
}

export class TransactionCategory implements ITransactionCategory {
    id!: number;
    name!: string;
    root?: TransactionCategoryLeaf | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: ITransactionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.root = _data["root"] ? TransactionCategoryLeaf.fromJS(_data["root"]) : <any>undefined;
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["root"] = this.root ? this.root.toJSON() : <any>undefined;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionCategory {
    id: number;
    name: string;
    root?: TransactionCategoryLeaf | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class TransactionCategoryLeaf implements ITransactionCategoryLeaf {
    id!: number;
    name?: string | undefined;
    rootId?: number | undefined;
    links?: Link[] | undefined;

    constructor(data?: ITransactionCategoryLeaf) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.rootId = _data["rootId"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TransactionCategoryLeaf {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionCategoryLeaf();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["rootId"] = this.rootId;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITransactionCategoryLeaf {
    id: number;
    name?: string | undefined;
    rootId?: number | undefined;
    links?: Link[] | undefined;
}

export class TransactionStatus implements ITransactionStatus {
    id!: TransactionStatusValue;
    name?: string | undefined;
    ordinal!: number;

    constructor(data?: ITransactionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.ordinal = _data["ordinal"];
        }
    }

    static fromJS(data: any): TransactionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new TransactionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["ordinal"] = this.ordinal;
        return data; 
    }
}

export interface ITransactionStatus {
    id: TransactionStatusValue;
    name?: string | undefined;
    ordinal: number;
}

export enum TransactionStatusValue {
    Planned = 100,
    Awaiting = 200,
    Paid = 300,
    Outdated = 400,
}

export class RecurringTransaction implements IRecurringTransaction {
    id!: number;
    user?: UserLeaf | undefined;
    sender?: Account | undefined;
    receiver?: Account | undefined;
    type?: string | undefined;
    category?: TransactionCategory | undefined;
    currency?: Currency | undefined;
    description?: string | undefined;
    amount!: number;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: IRecurringTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.user = _data["user"] ? UserLeaf.fromJS(_data["user"]) : <any>undefined;
            this.sender = _data["sender"] ? Account.fromJS(_data["sender"]) : <any>undefined;
            this.receiver = _data["receiver"] ? Account.fromJS(_data["receiver"]) : <any>undefined;
            this.type = _data["type"];
            this.category = _data["category"] ? TransactionCategory.fromJS(_data["category"]) : <any>undefined;
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : <any>undefined;
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RecurringTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new RecurringTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["receiver"] = this.receiver ? this.receiver.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IRecurringTransaction {
    id: number;
    user?: UserLeaf | undefined;
    sender?: Account | undefined;
    receiver?: Account | undefined;
    type?: string | undefined;
    category?: TransactionCategory | undefined;
    currency?: Currency | undefined;
    description?: string | undefined;
    amount: number;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class PagedDataInquiryResponseOfRecurringTransaction implements IPagedDataInquiryResponseOfRecurringTransaction {
    items?: RecurringTransaction[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfRecurringTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(RecurringTransaction.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfRecurringTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfRecurringTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfRecurringTransaction {
    items?: RecurringTransaction[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewRecurringTransaction implements INewRecurringTransaction {
    user!: User;
    sender!: Account;
    receiver!: Account;
    type!: TransactionType;
    category!: TransactionCategory;
    currency!: Currency;
    description!: string;
    amount!: number;

    constructor(data?: INewRecurringTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.sender = new Account();
            this.receiver = new Account();
            this.type = new TransactionType();
            this.category = new TransactionCategory();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.sender = _data["sender"] ? Account.fromJS(_data["sender"]) : new Account();
            this.receiver = _data["receiver"] ? Account.fromJS(_data["receiver"]) : new Account();
            this.type = _data["type"] ? TransactionType.fromJS(_data["type"]) : new TransactionType();
            this.category = _data["category"] ? TransactionCategory.fromJS(_data["category"]) : new TransactionCategory();
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.description = _data["description"];
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): NewRecurringTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new NewRecurringTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["receiver"] = this.receiver ? this.receiver.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface INewRecurringTransaction {
    user: User;
    sender: Account;
    receiver: Account;
    type: TransactionType;
    category: TransactionCategory;
    currency: Currency;
    description: string;
    amount: number;
}

export class User extends UserLeaf implements IUser {
    roles?: Role[] | undefined;

    constructor(data?: IUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IUser extends IUserLeaf {
    roles?: Role[] | undefined;
}

export class Task implements ITask {
    id!: number;
    subject?: string | undefined;
    startDate?: string | undefined;
    dueDate?: string | undefined;
    createdDate?: string | undefined;
    completedDate?: string | undefined;
    transactionStatus?: TransactionStatus | undefined;
    assignees?: UserLeaf[] | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;

    constructor(data?: ITask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.subject = _data["subject"];
            this.startDate = _data["startDate"];
            this.dueDate = _data["dueDate"];
            this.createdDate = _data["createdDate"];
            this.completedDate = _data["completedDate"];
            this.transactionStatus = _data["transactionStatus"] ? TransactionStatus.fromJS(_data["transactionStatus"]) : <any>undefined;
            if (Array.isArray(_data["assignees"])) {
                this.assignees = [] as any;
                for (let item of _data["assignees"])
                    this.assignees!.push(UserLeaf.fromJS(item));
            }
            this.version = _data["version"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Task {
        data = typeof data === 'object' ? data : {};
        let result = new Task();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["subject"] = this.subject;
        data["startDate"] = this.startDate;
        data["dueDate"] = this.dueDate;
        data["createdDate"] = this.createdDate;
        data["completedDate"] = this.completedDate;
        data["transactionStatus"] = this.transactionStatus ? this.transactionStatus.toJSON() : <any>undefined;
        if (Array.isArray(this.assignees)) {
            data["assignees"] = [];
            for (let item of this.assignees)
                data["assignees"].push(item.toJSON());
        }
        data["version"] = this.version;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        return data; 
    }
}

export interface ITask {
    id: number;
    subject?: string | undefined;
    startDate?: string | undefined;
    dueDate?: string | undefined;
    createdDate?: string | undefined;
    completedDate?: string | undefined;
    transactionStatus?: TransactionStatus | undefined;
    assignees?: UserLeaf[] | undefined;
    version?: string | undefined;
    links?: Link[] | undefined;
}

export class PagedDataInquiryResponseOfTask implements IPagedDataInquiryResponseOfTask {
    items?: Task[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfTask) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(Task.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfTask {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfTask();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfTask {
    items?: Task[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewTransactionCategory implements INewTransactionCategory {
    name!: string;
    root?: TransactionCategoryLeaf | undefined;

    constructor(data?: INewTransactionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.root = _data["root"] ? TransactionCategoryLeaf.fromJS(_data["root"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewTransactionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new NewTransactionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["root"] = this.root ? this.root.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INewTransactionCategory {
    name: string;
    root?: TransactionCategoryLeaf | undefined;
}

export class PagedDataInquiryResponseOfTransactionCategory implements IPagedDataInquiryResponseOfTransactionCategory {
    items?: TransactionCategory[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfTransactionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionCategory.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfTransactionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfTransactionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfTransactionCategory {
    items?: TransactionCategory[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewTransaction implements INewTransaction {
    date!: string;
    user!: UserLeaf;
    sender!: Account;
    receiver!: Account;
    type!: TransactionType;
    category!: TransactionCategory;
    status!: TransactionStatus;
    currency!: Currency;
    description!: string;
    amount!: number;
    recurringTransaction?: RecurringTransaction | undefined;

    constructor(data?: INewTransaction) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new UserLeaf();
            this.sender = new Account();
            this.receiver = new Account();
            this.type = new TransactionType();
            this.category = new TransactionCategory();
            this.status = new TransactionStatus();
            this.currency = new Currency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"];
            this.user = _data["user"] ? UserLeaf.fromJS(_data["user"]) : new UserLeaf();
            this.sender = _data["sender"] ? Account.fromJS(_data["sender"]) : new Account();
            this.receiver = _data["receiver"] ? Account.fromJS(_data["receiver"]) : new Account();
            this.type = _data["type"] ? TransactionType.fromJS(_data["type"]) : new TransactionType();
            this.category = _data["category"] ? TransactionCategory.fromJS(_data["category"]) : new TransactionCategory();
            this.status = _data["status"] ? TransactionStatus.fromJS(_data["status"]) : new TransactionStatus();
            this.currency = _data["currency"] ? Currency.fromJS(_data["currency"]) : new Currency();
            this.description = _data["description"];
            this.amount = _data["amount"];
            this.recurringTransaction = _data["recurringTransaction"] ? RecurringTransaction.fromJS(_data["recurringTransaction"]) : <any>undefined;
        }
    }

    static fromJS(data: any): NewTransaction {
        data = typeof data === 'object' ? data : {};
        let result = new NewTransaction();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["sender"] = this.sender ? this.sender.toJSON() : <any>undefined;
        data["receiver"] = this.receiver ? this.receiver.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["status"] = this.status ? this.status.toJSON() : <any>undefined;
        data["currency"] = this.currency ? this.currency.toJSON() : <any>undefined;
        data["description"] = this.description;
        data["amount"] = this.amount;
        data["recurringTransaction"] = this.recurringTransaction ? this.recurringTransaction.toJSON() : <any>undefined;
        return data; 
    }
}

export interface INewTransaction {
    date: string;
    user: UserLeaf;
    sender: Account;
    receiver: Account;
    type: TransactionType;
    category: TransactionCategory;
    status: TransactionStatus;
    currency: Currency;
    description: string;
    amount: number;
    recurringTransaction?: RecurringTransaction | undefined;
}

export class PagedDataInquiryResponseOfTransactionStatus implements IPagedDataInquiryResponseOfTransactionStatus {
    items?: TransactionStatus[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfTransactionStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionStatus.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfTransactionStatus {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfTransactionStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfTransactionStatus {
    items?: TransactionStatus[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class PagedDataInquiryResponseOfTransactionType implements IPagedDataInquiryResponseOfTransactionType {
    items?: TransactionType[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfTransactionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(TransactionType.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfTransactionType {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfTransactionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfTransactionType {
    items?: TransactionType[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class PagedDataInquiryResponseOfUser implements IPagedDataInquiryResponseOfUser {
    items?: User[] | undefined;
    pageSize!: number;
    links?: Link[] | undefined;
    pageNumber!: number;
    pageCount!: number;

    constructor(data?: IPagedDataInquiryResponseOfUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(User.fromJS(item));
            }
            this.pageSize = _data["pageSize"];
            if (Array.isArray(_data["links"])) {
                this.links = [] as any;
                for (let item of _data["links"])
                    this.links!.push(Link.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): PagedDataInquiryResponseOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedDataInquiryResponseOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        data["pageSize"] = this.pageSize;
        if (Array.isArray(this.links)) {
            data["links"] = [];
            for (let item of this.links)
                data["links"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageCount"] = this.pageCount;
        return data; 
    }
}

export interface IPagedDataInquiryResponseOfUser {
    items?: User[] | undefined;
    pageSize: number;
    links?: Link[] | undefined;
    pageNumber: number;
    pageCount: number;
}

export class NewUser implements INewUser {
    login!: string;
    password!: string;
    firstname!: string;
    lastname!: string;
    email!: string;
    roles?: Role[] | undefined;

    constructor(data?: INewUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.password = _data["password"];
            this.firstname = _data["firstname"];
            this.lastname = _data["lastname"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(Role.fromJS(item));
            }
        }
    }

    static fromJS(data: any): NewUser {
        data = typeof data === 'object' ? data : {};
        let result = new NewUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        data["firstname"] = this.firstname;
        data["lastname"] = this.lastname;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item.toJSON());
        }
        return data; 
    }
}

export interface INewUser {
    login: string;
    password: string;
    firstname: string;
    lastname: string;
    email: string;
    roles?: Role[] | undefined;
}

export class AuthenticatedData implements IAuthenticatedData {
    userId!: number;
    token?: string | undefined;

    constructor(data?: IAuthenticatedData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.token = _data["token"];
        }
    }

    static fromJS(data: any): AuthenticatedData {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticatedData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["token"] = this.token;
        return data; 
    }
}

export interface IAuthenticatedData {
    userId: number;
    token?: string | undefined;
}

export class LoginData implements ILoginData {
    login!: string;
    password!: string;

    constructor(data?: ILoginData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.login = _data["login"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): LoginData {
        data = typeof data === 'object' ? data : {};
        let result = new LoginData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["login"] = this.login;
        data["password"] = this.password;
        return data; 
    }
}

export interface ILoginData {
    login: string;
    password: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}